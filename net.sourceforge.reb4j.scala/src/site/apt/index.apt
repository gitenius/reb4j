Usage

	The general process of using <<reb4j>> consists of building up an
	expression from sub-expressions, then calling the 
	{{{./scaladocs/net/sourceforge/reb4j/scala/Expression.html#toRegex()}toRegex}}
	method of the constructed expression in order to compile the expression.
	
	Expressions are represented by the 
	{{{./scaladocs/net/sourceforge/reb4j/scala/Expression.html}Expression}} class, instances of
	which are immutable after being constructed, which allows a single
	instance to be re-used as a sub-expression in many different expressions.
	
	There is one sub-class, 
	{{{./scaladocs/net/sourceforge/reb4j/scala/charclass/CharClass.html}CharClass}}, which
	represents the specialized case of character classes (usually represented 
	in regular expressions as ranges of characters surrounded by square
	brackets.  Character classes (instances of 
	{{{./scaladocs/net/sourceforge/reb4j/scala/charclass/CharClass.html}CharClass}}) may be 
	composed from other character classes, and larger expressions may be
	composed from character classes, but character classes cannot be
	composed from non-character class expressions (hence the need for a
	separate class to distinguish them).
	
* Expression Types
	
	<<reb4j>> provides the means to programmatically utilize any of the features of the 
	{{{http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html}java.util.regex.Pattern}}
	class.  As such, there are many ways to build up regular expressions 
	from their elemental parts.
	
** Literals
	
	The simplest type of sub-expression you are likely to need is a 
	basic string match.  <<reb4j>> makes this easy with the Literal
	function object. 
			
-------------------------------------------------------------------------------
val aBunchOfBracketsFollowedByAnA = Literal("[[[[[A")
val justA = Literal('a') // single-character literals have special semantics
-------------------------------------------------------------------------------

	Notice that <<reb4j>> handles escaping characters that have special
	meaning in regular expressions, so you do not need to
	concern yourself with it.
			
** Sequences
		
	A common way to compose two or more expressions to is to define
	a sequence of expressions that are to appear in a particular
	order in the input.  <<reb4j>> provides both an operator and a named 
	method for accomplishing this, which you can use according to your
	preference of style.

-------------------------------------------------------------------------------
val abcd = Literal("ab") ~~ Literal("cd")
val efgh = Literal("ef") andThen Literal("gh")
-------------------------------------------------------------------------------			
			
** Alternation
		
	Another common way to compose two or more expressions is to define
	alternates, with the composed expression representing the logical
	OR of the subexpressions.  In regular expressions, this is
	indicated by the | character.  In <<reb4j>>, it is accomplished
	using the either the || operator or the named "or" method.
			
-------------------------------------------------------------------------------
val a_or_b = Literal("a") || Literal("b")
val c_or_d = Literal("c") or Literal("d")
-------------------------------------------------------------------------------
			
** Quantifiers
		
	One of the most important features of regular expressions is the
	ability to indicate that a sub-expression may (or must) appear
	multiple times.  This is expressed using quantifiers.
	
*** Kleene Star
	
	The most fundamental type of quantifier is the Kleene Star,
	which is indicated by an asterisk (*) in most regular
	expression languages.  It indicates that the preceding
	sub-expression may appear zero or more times in a row.
	<<reb4j>> supports this with your choice of either a postfix
	operator or a named method.

-------------------------------------------------------------------------------
val zeroOrMore_a = Literal('a') *
val zeroOrMore_b = Literal('b').anyTimes
-------------------------------------------------------------------------------
			
*** One or More

	As an extension to the Kleene Star, most regular expression
	languages support a means to indicate that an expression must
	appear at least once.  This is typically done with the plus (+)
	operator.  <<reb4j>> provides support for this both an operator
	and a named method.
				
-------------------------------------------------------------------------------
val a_repeating = Literal('a') +
val b_repeating = Literal('b').atLeastOnce
-------------------------------------------------------------------------------
			
*** Optional

	It is also possible to indicate that a sub-expression may
	appear exactly once or not at all, using the ? operator.
	<<reb4j>> provides for this as well.
				
-------------------------------------------------------------------------------
val bOrNotB = Literal('b') ?
val cOrNotC = Literal('c').optional
-------------------------------------------------------------------------------

*** Bounded Repetition

	The {{{http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html}Pattern}}
	class allows for a specific number of repetitions or range of 
	repetitions to be specified by enclosing the bounds in curly 
	braces ({}), and in the case of a range of values, separating 
	the minimum and maximum counts with a comma (,), possibly
	omitting either bound.  <<reb4j>> supports all possibilities
	with a range of named methods.
				
-------------------------------------------------------------------------------
val a = Literal('a')
val a_4_times = a.repeat(4) // exactly 4 times
val a_between_3_and_6_times = a.repeat(3, 6) // betwen 3 and 6 repetitions
val a_at_least_5_times = a.atLeast(5) // at least 5 repetitions
val a_at_most_twice = a.repeat(0, 2) // no more than 2 repetitions
-------------------------------------------------------------------------------

** Capturing Groups

	The {{{http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html}Pattern}}
	class allows you to indicate (using unqualified parentheses)
	sub-expressions that are to be used as "capturing groups".  These
	groups are implicitly numbered in the order they appear in the
	regular expression, and, if they match, the segments of the input
	that matched each group can be independently obtained.
	To designate a sub-expression as a capturing group with <<reb4j>>,
	use the Capture class within the Group module.
	Be sure to pay attention to how your final expression is constructed.
	The groups will be numbered according to the order in which they begin
	in the final regular expression, which is not necessarily the same as
	the order you invoke the Capture class.
		
-------------------------------------------------------------------------------
val ABCs = Group.NonCapturing(Literal("ABC")).atLeastOnce
val oneTwoThrees = Group.NonCapturing(Literal("123")).atLeastOnce
val ABCsAndOneTwoThrees = Group.Capture(ABCs) + oneTwoThrees
val pattern = ABCsAndOneTwoThrees.toPattern
val matcher = pattern.matcher("ABCABCABC123123123")
if (matcher.matches())
	Some(matcher.group(1))
else
	None
-------------------------------------------------------------------------------
			
** Character Classes
		
	It is often necessary to define a sub-expression that will match many occurrences
	of any of a set of characters through the use of "character classes". The
	{{{http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html}Pattern}}
	class provides a number of predefined character classes, as well as
	provides a facility to define custom character classes by enclosing
	characters, ranges of characters, or character classes in square brackets.
	Since character classes may be composed from other character classes, 
	<<reb4j>> provides a separate class,
	{{{./scaladocs/net/sourceforge/reb4j/scala/charclass/CharClass.html}CharClass}}, which
	contains static methods for working	with character classes.  Note that 
	{{{./scaladocs/net/sourceforge/reb4j/scala/charclass/CharClass.html}CharClass}} extends
	{{{./scaladocs/net/sourceforge/reb4j/scala/Expression.html}Expression}}, so instances may be
	used in any context in which a 
	{{{./scaladocs/net/sourceforge/reb4j/scala/Expression.html}Expression}} would be valid.
	
*** Predefined Classes

	The {{{./scaladocs/net/sourceforge/reb4j/scala/charclass/CharClass.html}CharClass}} class
	provides constants that represent the various predefined character classes
	that the 
	{{{http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html}Pattern}}
	class supports.  Examples of these include
	{{{./scaladocs/net/sourceforge/reb4j/scala/charclass/CharClass$$Perl$.html#Digit}CharClass.Perl.Digit}},
	which corresponds to the Perl-style regular expression <<<"\d">>> (representing 
	a digit), and 
	{{{./scaladocs/net/sourceforge/reb4j/scala/charclass/CharClass$$Posix$.html#Alnum}CharClass.Posix.Alnum}},
	which corresponds to the POSIX named character class expression <<<"\p{Alnum}">>>.
	Consult the {{{./scaladocs/net/sourceforge/reb4j/charclass/CharClass.html}Javadocs}}
	for the complete list of available constants.
	
*** Lists of Characters

	To define a character class that will match any of a series of characters,
	simply pass those characters as a 
	{{{http://java.sun.com/javase/6/docs/api/java/lang/String.html}String}} to 
	the {{{./scaladocs/net/sourceforge/reb4j/scala/charclass/CharClass.html#chars(Traversable[Char]):MultiChar}CharClass.characters}}
	method. 
	
-------------------------------------------------------------------------------
val abc = CharClass.chars("abc")
-------------------------------------------------------------------------------

*** Character Ranges

	To define a character class that matches any characters whose ordinal
	values are between a minimum and maximum character (inclusive), use the
	{{{./scaladocs/net/sourceforge/reb4j/scala/charclass/CharClass.html#range(Char,Char):CharRange}CharClass.range}}
	method.
	
-------------------------------------------------------------------------------
val a_thru_m = CharClass.range('a', 'm')
-------------------------------------------------------------------------------

*** Composing Character Classes

	Instances of {{{./scaladocs/net/sourceforge/reb4j/scala/charclassCharClass.html}CharClass}}
	may be built from other instances.
	
**** Negation

	To construct a character class that will match any character that is <not>
	in another character specified character class, use either the 
	{{{./scaladocs/net/sourceforge/reb4j/scala/charclass/CharClass.html#negated:CharClass}CharClass.negated}}
	method or the {{{./scaladocs/net/sourceforge/reb4j/scala/charclass/CharClass.html#unary_~:CharClass}unary ~ operator}}.
	
-------------------------------------------------------------------------------
val notALetter = CharClass.Posix.Alpha.negated
val notANumber = ~CharClass.Posix.Digit
-------------------------------------------------------------------------------
	
**** Union

	To construct a character class that will match any character that would be
	matched by two or more other character classes, use the
	{{{./scaladocs/net/sourceforge/reb4j/charclass/Union$$Ops.html#union(Subset):CharClass}Union.Ops.union}}
	method or the {{{./scaladocs/net/sourceforge/reb4j/charclass/Union$$Ops.html#||(Subset):Union} || operator}}.
	
-------------------------------------------------------------------------------
val oneThruFive = CharClass.range('1, 5')
val threeThruEight = CharClass.range('3, '8')
val oneThruEight = oneThruFive || threeThruEight
val oneThruEightAgain = oneThruFive union threeThruEight
-------------------------------------------------------------------------------

**** Intersection

	To construct a character class that will match only those characters that
	appear in all of several other character classes, use the
	{{{./scaladocs/net/sourceforge/reb4j/scala/charclass/Intersection$$Ops.html#intersect(Superset):Intersection}Intersection.Ops.intersect}}
	method or the {{{./scaladocs/net/sourceforge/reb4j/scala/charclass/Intersection$$Ops.html#||(Superset):Intersection} && operator}}.
	
-------------------------------------------------------------------------------
val vowels = CharClass.chars("AaEeIiOoUu")
val consonants = CharClass.Posix.Alpha intersect (~vowels)
val consonantsAgain = CharClass.Posix.Alpha && ~vowels
-------------------------------------------------------------------------------
		
** Adopting Patterns
	
	Sometimes it may be useful to include a regular expression that has
	already been compiled into a
	{{{http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html}Pattern}}
	object as a sub-expression in an expression constructed by <<reb4j>>.
	This can be accomplished using the factory methods in the
	{{{./scaladocs/net/sourceforge/reb4j/scala/Adopted$.html}Adopted}}
	singleton, which accept a
	{{{http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html}Pattern}}
	or Regex as an argument and constructs a new 
	{{{./scaladocs/net/sourceforge/reb4j/scala/Expression.html}Expression}}
	from it.
	
-------------------------------------------------------------------------------
val regex = "abc".r
val adopted = Adopted.fromRegex(regex)
-------------------------------------------------------------------------------
